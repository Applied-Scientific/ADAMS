"""
Agent utility functions for MD analysis pipeline.

Functions exposed to the agent for building file paths and discovering tool paths.
"""

import glob
import os
from typing import Any, Optional

from agents import function_tool

from ...logger_utils import get_logger


@function_tool
def build_file_paths(
    md_workdir: str = None,
    existing_md_root: str = None,
    protein_gro: str = None,
    protein_top: str = None,
    posre_itp: str = None,
    docking_csv: str = None,
    ligand_input: str = None,
    poses_dir: str = None,
    protein_file: str = None,
) -> Any:
    """
    Build file_paths dictionary from explicit paths, filtering out None/empty values.

    This dictionary is the single source of truth for ALL paths (directories and files).
    It consolidates what was previously split between dir_structure and file_paths.

    Use this function to initialize the file_paths dictionary before calling any MD module.
    The returned dictionary should be passed to each module tool function.

    Args:
        md_workdir: MD working directory root (used to derive other dirs if not provided).
                   Creates a new md_analysis/ subdirectory structure.
        existing_md_root: Path to an existing md_analysis directory to discover files from.
                         Use this to continue/resume from a previous run.
                         If provided, will scan for existing files and populate paths.
        protein_file: Path to input protein PDB file (for ProteinTopology step)
        protein_gro: Path to protein GRO file (output from ProteinTopology)
        protein_top: Path to protein topology file (output from ProteinTopology)
        posre_itp: Path to position restraints file (output from ProteinTopology via pdb2gmx)
        docking_csv: Path to docking results CSV (input for LigPrepare)
        ligand_input: Ligand structure input - can be:
            - SMILES string: "CC(=O)O" (for single ligand only)
            - CSV file: Path to CSV with SMILES column (flexible column names)
            - SDF/MOL2 file: Path to structure file
            - Directory: Path containing structure files
        poses_dir: Directory containing pose subdirectories (used by Gro and StabilityAnalysis)

    Returns:
        dict: File paths dictionary with only non-empty values

    Directory keys (auto-created from md_workdir if provided):
        - md_root: Root MD analysis directory
        - protein_dir: Directory for protein topology files
        - poses_dir: Directory containing pose subdirectories
        - reports_dir: Directory for analysis reports

    File keys (explicitly provided or generated by pipeline steps):
        - protein_file: Input protein PDB file
        - protein_gro: Protein structure in GRO format
        - protein_top: Protein topology file
        - posre_itp: Position restraints ITP file (created alongside protein_top)
        - docking_csv: Docking results CSV
        - ligand_input: Ligand structure input (SMILES string, CSV, SDF, MOL2, or directory)

    Example:
        >>> # Start fresh - create new directory structure
        >>> file_paths = build_file_paths(
        ...     md_workdir="/path/to/output",
        ...     protein_file="/path/to/protein.pdb",
        ...     ligand_input="/path/to/ligands.csv"
        ... )

        >>> # Resume from existing run - discover existing files
        >>> file_paths = build_file_paths(
        ...     existing_md_root="/path/to/output/md_analysis",
        ...     docking_csv="/path/to/new_docking.csv",
        ...     ligand_input="CC(=O)O"  # SMILES string
        ... )
    """
    paths = {}

    if existing_md_root and os.path.isdir(existing_md_root):
        paths = discover_file_paths(existing_md_root)
        # Ensure reports_dir is set even if it doesn't exist yet (will be created by modules that need it)
        if "md_root" in paths and "reports_dir" not in paths:
            paths["reports_dir"] = os.path.join(paths["md_root"], "reports")
    elif md_workdir:
        md_root = os.path.join(md_workdir, "md_analysis")
        paths["md_root"] = md_root
        paths["protein_dir"] = os.path.join(md_root, "protein")
        paths["poses_dir"] = os.path.join(md_root, "poses")
        paths["reports_dir"] = os.path.join(md_root, "reports")

    if protein_file:
        paths["protein_file"] = protein_file
    if protein_gro:
        paths["protein_gro"] = protein_gro
    if protein_top:
        paths["protein_top"] = protein_top
    if posre_itp:
        paths["posre_itp"] = posre_itp
    if docking_csv:
        paths["docking_csv"] = docking_csv
    if ligand_input:
        paths["ligand_input"] = ligand_input
    if poses_dir:
        paths["poses_dir"] = poses_dir

    return paths


def discover_file_paths(md_root: str) -> Any:
    """
    Discover existing files and directories from an MD analysis directory structure.

    Use this to resume or continue from an existing run by scanning the directory
    and populating file_paths with discovered files.

    Args:
        md_root: Path to the MD analysis root directory (e.g., .../md_analysis/)
                 This should be the directory containing protein/, poses/, reports/

    Returns:
        dict: file_paths dictionary populated with discovered paths

    Directory structure expected:
        md_root/
        ├── protein/           # protein_dir
        │   ├── protein.gro    # protein_gro
        │   ├── topol.top      # protein_top
        │   └── posre.itp      # posre_itp
        ├── poses/             # poses_dir
        │   └── {ligand}_pocket_{grid}_top{rank}/
        └── reports/           # reports_dir
    """
    logger = get_logger()

    if not os.path.isdir(md_root):
        raise FileNotFoundError(f"MD root directory not found: {md_root}")

    paths = {"md_root": md_root}

    protein_dir = os.path.join(md_root, "protein")
    if os.path.isdir(protein_dir):
        paths["protein_dir"] = protein_dir

        protein_gro = os.path.join(protein_dir, "protein.gro")
        if os.path.exists(protein_gro):
            paths["protein_gro"] = protein_gro

        protein_top = os.path.join(protein_dir, "topol.top")
        if os.path.exists(protein_top):
            paths["protein_top"] = protein_top

        posre_itp = os.path.join(protein_dir, "posre.itp")
        if os.path.exists(posre_itp):
            paths["posre_itp"] = posre_itp

    poses_dir = os.path.join(md_root, "poses")
    if os.path.isdir(poses_dir):
        paths["poses_dir"] = poses_dir

    reports_dir = os.path.join(md_root, "reports")
    if os.path.isdir(reports_dir):
        paths["reports_dir"] = reports_dir

        for report_type, pattern in [
            ("summary_report", "md_analysis_summary_*.csv"),
            ("brief_report", "brief_report_*.csv"),
        ]:
            matches = glob.glob(os.path.join(reports_dir, pattern))
            if matches:
                paths[report_type] = max(matches, key=os.path.getmtime)

    logger.info(f"Discovered file_paths from {md_root}:")
    for key, value in paths.items():
        logger.info(f"  {key}: {value}")

    return paths


@function_tool
def discover_paths(
    gromacs_path: Optional[str] = None,
    ambertools_path: Optional[str] = None,
    gromacs_priority: str = "mpi",
) -> Any:
    """
    Discover GROMACS and AmberTools installation paths from conda environment.

    This function should be called by the agent before running any MD modules to
    discover the paths to GROMACS and AmberTools. The returned paths should be merged
    into the file_paths dictionary.

    There are 3 GROMACS binary types available:
    - CUDA: $CONDA_PREFIX/gromacs-2024.4/cuda/bin (contains gmx)
    - MPI: $CONDA_PREFIX/gromacs-2024.4/bin (contains gmx_mpi)
    - Standard: $CONDA_PREFIX/gromacs-2024.4/bin (contains gmx)

    Args:
        gromacs_path: Optional explicit path to GROMACS bin directory. If provided and valid,
                     function returns immediately with detected binary type.
        ambertools_path: Optional explicit path to AmberTools home directory. If provided and valid,
                        function uses it directly.
        gromacs_priority: Priority order for auto-detection when multiple versions exist.
                         Options: "cuda", "mpi", "standard" (default: "mpi")

    Returns:
        dict: Dictionary with keys:
            - gromacs_path: Path to GROMACS bin directory
            - ambertools_path: Path to AmberTools home directory
            - gromacs_binary_type: Detected binary type ("cuda", "mpi", or "standard")

    Raises:
        EnvironmentError: If user-provided paths don't exist or paths cannot be discovered

    Example:
        >>> paths = discover_paths()
        >>> file_paths.update(paths)
        >>>
        >>> # Prefer CUDA version
        >>> paths = discover_paths(gromacs_priority="cuda")
    """
    logger = get_logger()

    if gromacs_path and os.path.exists(gromacs_path):
        gmx_path = os.path.join(gromacs_path, "gmx")
        gmx_mpi_path = os.path.join(gromacs_path, "gmx_mpi")

        if "/cuda/bin" in gromacs_path and os.path.exists(gmx_path):
            binary_type = "cuda"
        elif os.path.exists(gmx_mpi_path):
            binary_type = "mpi"
        elif os.path.exists(gmx_path):
            binary_type = "standard"
        else:
            binary_type = "standard"
            logger.warning(
                f"Could not detect binary type from {gromacs_path}, defaulting to 'standard'"
            )

        ambertools_path = ambertools_path or os.environ.get("CONDA_PREFIX")
        if not ambertools_path or not os.path.exists(ambertools_path):
            raise EnvironmentError(f"AmberTools home not found: {ambertools_path}")

        logger.info(
            f"Using provided paths: GROMACS={gromacs_path}, binary_type={binary_type}"
        )
        return {
            "gromacs_path": gromacs_path,
            "ambertools_path": ambertools_path,
            "gromacs_binary_type": binary_type,
        }

    if gromacs_path:
        raise EnvironmentError(f"GROMACS bin directory not found: {gromacs_path}")

    conda_prefix = os.environ.get("CONDA_PREFIX")
    if not conda_prefix:
        raise EnvironmentError(
            "CONDA_PREFIX not set. Please set gromacs_path and ambertools_path explicitly "
            "or ensure you're in a conda environment."
        )

    gromacs_base = os.path.join(conda_prefix, "gromacs-2024.4")
    search_paths = []

    if gromacs_priority == "cuda":
        search_paths = [
            (os.path.join(gromacs_base, "cuda", "bin"), "cuda"),
            (os.path.join(gromacs_base, "bin"), "mpi"),
            (os.path.join(gromacs_base, "bin"), "standard"),
        ]
    elif gromacs_priority == "mpi":
        search_paths = [
            (os.path.join(gromacs_base, "bin"), "mpi"),
            (os.path.join(gromacs_base, "cuda", "bin"), "cuda"),
            (os.path.join(gromacs_base, "bin"), "standard"),
        ]
    else:  # standard
        search_paths = [
            (os.path.join(gromacs_base, "bin"), "standard"),
            (os.path.join(gromacs_base, "bin"), "mpi"),
            (os.path.join(gromacs_base, "cuda", "bin"), "cuda"),
        ]

    gromacs_path = None
    binary_type = None
    for path, btype in search_paths:
        if os.path.exists(path):
            if btype == "cuda" and os.path.exists(os.path.join(path, "gmx")):
                gromacs_path = path
                binary_type = "cuda"
                break
            elif btype == "mpi" and os.path.exists(os.path.join(path, "gmx_mpi")):
                gromacs_path = path
                binary_type = "mpi"
                break
            elif btype == "standard" and os.path.exists(os.path.join(path, "gmx")):
                gromacs_path = path
                binary_type = "standard"
                break

    if not gromacs_path:
        raise EnvironmentError(
            f"GROMACS not found. Expected locations:\n"
            f"  - {os.path.join(gromacs_base, 'bin')}\n"
            f"  - {os.path.join(gromacs_base, 'cuda', 'bin')}\n"
            f"Please set gromacs_path explicitly or ensure GROMACS is installed."
        )

    ambertools_path = ambertools_path or conda_prefix
    if not os.path.exists(ambertools_path):
        raise EnvironmentError(f"AmberTools home not found: {ambertools_path}")

    logger.info(
        f"Discovered paths: GROMACS={gromacs_path}, AMBERHOME={ambertools_path}, "
        f"binary_type={binary_type}"
    )

    return {
        "gromacs_path": gromacs_path,
        "ambertools_path": ambertools_path,
        "gromacs_binary_type": binary_type,
    }
